Day1:
learned some of the basics of OOP and regexs, recalled basics of counters and print checks.
Day2:

Day9:
can't put hashable objects in unhashable ones (well, py doesn't allow you to, for good reason), learned a bit about how to make venvs to avoid import errors, some of the basics of numpy arrays
noted that the return statement will break out of the function which can be used for really clean if statements, also used sets for keeping track of things that ignore duplicates which felt like a sweet 'data types ftw!' moment. Venvs have .gitignore in them as a good practice since apparently things can get messy with moving around venvs. learned it the hard way. But also learned that ChatGPT can just do most of what you spent a whole day on with a prompth you just put together in 5 minutes because AAAAAAH what am I supposed to feel about this? On the one hand it's taking away a lot of the boring mundane parts of programming and intellectual tasks, on the other hand it might be capable of more than that and I'd like to do those non-mundane things myself and be considered valuable because of being able to do that, and like, a lot of what I/we do was mundane and I don't know how we're gonna be able to adjust now that all that shit seems to be easily done by a scalable software. 
is keyword: it's used to determine if two things have the same memory location. like == but for the "memory index". if a = 1 and b = 1 we have a == b but not a is b. but if we have c = a then a is c returns true. GPT used it to see if a is None. a is b implies a == b but not vv. can use a == None to get the same result, but is a bit less appropriate, ambiguous and less "pythonic". 
in keyword: can be used both as a \in sort of bool function and as a pointer(what I assume a pointer is) sort of function.
more concise code isn't necessarily better. the way I code I'd have something like if self.pos[0] < self.leader.pos[0]: self.pos += 1 and so on, but the way chatgpt did it was by giving the leader and self's position more intuitive name as temps, and worked with that. Makes it a lot more readable so it's easier to see what might be wrong if I were to have written it and wanted to debug. On the other hand it's more noobish if I were to have made it myself. 
with: basically a wrapper performing open() and close() before and after what you do. it's a nice and neat / orderly QoL thing functioning like a do block or an io wrapper. (technically it's a bit more precise and uses the __enter__() and __exit__() methods but idk about those so we'll leave it at that.)
as just gives an object an alias to refer to it with. 
<class '_io.TextIOWrapper'>

ord() and char() functions are delightful

eval functions are a blessing I could've been using all along but it's fine. have the eval() which can potentially be unsafe (untrusted input or just bad code) and from the ast package the ast.literal_eval() which raises errors if things are fishy. still there are assumptions going into that function, and the safest way to handle this is with custom parsing tools for that document. 
try, except, else and finally: I've been waiting for this. try just runs sus code that might have issues and if it has errors instead of giving an error and stopping the code from running just performs the appropriate except block. here, else is for what happens if try DOESN'T RAISE ANY (accounted for) ERRORS and not for catching all other errors {that's except Exception}, and finally for code that should always run regardless. need to get more familiar with the types of error I encounter to use these but It's about time I get to doing that anyways. added some 5 common errors to the python_notes, and there is an Exception keyword that seems to catch all exceptions lol. 
pop() = pop(-1), list.pop(n) both returns the popped element and affects the list. so if I say x = l.pop() when l=[1,2,3] I get x = 3 and l = [1,2] from that point onward.
